# The Oko programming language

Язык отступо-зависим, 1 оттсуп - это либо таб(\t), либо 4 пробела

## Типы

Типы бывают двух видов:
* Скаляры - обыкновенные типы, состоящие из одного имени типа.
Примеры: `i32`, `myCustomType`, `bool`
* Кортежи - составные типы, состоят, соответственно, из любого кол-ва
других типов, в том числе и самих кортежей.
Примеры: `(i32, i32)`, `()`, `(i32)`, `(i32, (), i32, (bool, (bool)))`

## Структуры

Структуры определяются так:

```
ty <ИМЯ СТРУКТУРЫ>
    <ПОЛЯ>
```

Где <ПОЛЯ> это перечисление имён и типа с ними:

`variable: type`

`oneVariable secondVariable: type`

Можно объявлять несколько переменных одного типа через пробел

Пример структуры:

```
ty wrapper
	a b: bool
	x: i32
```
## Функции

Функции определяются так:

```
<ИМЯ ФУНКЦИИ> <АРГУМЕНТЫ> $(-> <ТИП ВОЗВРАТА>)?
    <ТЕЛО>
```

<АРГУМЕНТЫ> имеют тот же формат, что и <ПОЛЯ> у структуры

<ТИП ВОЗВРАТА> - тип значения, возвращаемого функцией.
Может не быть указан, в таком случае тип считается `()`.

<ТЕЛО> функции - это последовательность выражений, где каждое выражение
начинается с новой строки.

Последнее выражение в теле - возвращаемое значение.

Тело также не может не иметь выражений - это считается ошибкой,
если же вам нужна ничего не делающая функция, можете использовать
функцию `pass`

Тело функции кончается, когда уровень отступов становится меньше того,
какой был при её объявлении.

### Вызов функции

Вызов функции записывается так:
    `<ИМЯ ФУНКЦИИ> <АРГУМЕНТЫ>`

<АРГУМЕНТЫ> - это такие же выражения, перечисляемые через пробел

Есть нюанс: при вызове функции в условиях,
когда она не является частью вызова другой функции,
все аргументы передаются, пока не будет достигнут конец строки.

Если же эта функции является лишь одним из аргументов другой функции,
то считается, что она берёт ровно столько аргументов, сколько было указано
при её объявлении.

#### Пример
Функция a от 3‑х переменных
Функция b от 2-х переменных

`a arg1 b arg2 arg3 arg4`
воспринимается не как
`a(arg1, b(arg2, arg3, arg4))`,
а как
`a(arg1, b(arg2, arg3), arg4)`

Соответственно, если бы у a было 2 аргумента, а у b - 3,
то воспринималось бы оно первым способом

## Выражение

Выражение может быть:
- Унарным оператором:
    * Унарный плюс `+a`
    * Унарный минус `-a`
- Бинарным оператором
    * Умножение `a * b`
    * Деление `a / b`
    * Сложение `a + b`
    * Вычитание `a - b`
- Вызовом функции
- Именем переменной
- Обрамлённым в скобочки другим выражением `(a)`
- Кортежем `(a, b, c, (d, (), e))`

Чтобы создать единичный кортеж, требуется написать `(a,)`,
т.е. с запятой в конце - это нужно для отделения от скобок

В бинарных операциях есть небольшой нюанс,
но перед тем, как в него вдаваться, давайте разделим оформление
бинарных операций на четыре группы:

* Стандартная группа, вокруг оператора с обеих сторон есть пробелы: a + b
* Сжатая группа, вокруг оператора нет пробелов ни с одной из сторон: a+b
* Уродливая левая группа - пробел только слева: a +b
* Уродливая правая группа - пробел только справа: a+ b

В рамках языка программирования Oko, только первые две группы рассматриваются
как бинарный оператор - соответственно, `a + b` считается одним выражением,
а `a +b` - двумя, именем переменной и унарным оператором плюс

Это сделано для того, чтобы при вызове функции имелась возможность
вызывать её, как `someFunc someVar -anotherVar`, а не `someFunc somevar (-anotherVar)`.
В таком коде почти наверняка имелось ввиду не вычитание одним аргументом,
а два аргумента - простая переменная и унарный минус.
