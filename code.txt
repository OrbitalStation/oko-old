# Однострочные комменты

#[
    Многострочные
    комменты
]#

# Если комментарий находится перел функцией, до он становится частью её документации

# Аттрибут @default отвечает за всё, что генерируется у структуры по умолчанию

# У каждой структуры по умолчанию есть публичная функция new
# Которая просто принимает все поля типа и создаёт значение
# Это поведение можно регулировать подразделом аттрибута @default new на структуре
# @default new = none убирает эту функцию из типа насовсем,
# @default new = private меняет квалификатор доступа на этой функции и к ней становится
# нельзя обратиться извне типа

# Функции без аргументов вызываются, как и все остальные --
# someValue.someFunc, someFunc, someTy::someFunc
# Чтобы взять адрес функции, нужно написать перед именем &

# Вызов функции: в начале строчки имя функции, потом, до конца строки, аргументы.
# После вызова, используя 1 доп. отступ  можно через точку обращаться к полям/методам
# возвращённых функцией

# Аргументы функций могут состоять из скобок, и тогда там разрешено писать другие вызовы функций
# Также можно использовать оператор ~
#     a (b c) == a ~ b c
#     a (b (c d)) == a ~ b ~ c d
# Этот оператор просто добавляет один уровень вложенности скобок при каждой встрече выражения
# И добавляет закрывающие скобки в конец(сворачивается)
# принудительно свернуть оператор ~ может оператор ≁:
#     a (b (c d)) e (f g (h (i j)) k) == a ~ b ~ c d ≁ e (f g ~ h ~ i j ≁ k)
# Но так, конечно, лучше не писать :)

# Можно перед вызовом функции написать async и тогда функция будет выполняться конкуррентно к вызывающей,
# А также вернёт футуру, состояние которой можно опросить и сделать .await
# Можно также аннотировать функцию как @async only/none, и тогда эту функцию можно
# Будет вызывать только асинхронно/неасинхронно

# Вызов функции осуществляется так:
#     function - вызов обычной функции из глобальной области видимости
#     Type::function - вызов статической функции класса
#     exemplar.function - вызов нестатической функции класса от экземпляра

# Оператор ? применяется для тех же целей, что и в Rust-е
# Если значение имеет нестатический метод __try <Target, Error> -> TryFork <Target, Error>
# Где Target и Error определяются компилятором,
# То этот оператор может быть применён на этом значении
# Оператор имеет меньший приоритет, чем вызов функции, поэтому может быть
# Использован как someFunc someArgs... ?
# Для того, чтобы использовать на аргументе функции, оберните его в скобочки

# Можно также написать $value = перед вызовом функции, это запишет вернувшееся значение
# В переменную value. Декомпозинг производится как $(value1 value2) = ..., $[head, tail...] = ...

# Если тип аргумента

# Стейтмент if ->
# if <условие> then <выражение>
# if <условие>
#     <выражение 1>
#     <выражение 2>
#     ...
#     <выражение N>

# Option <SomeType> == SomeType?

add a b: i32 = a + b

enum Option <T>
    None
    Some T

use Option::None Some

ty ElementInfo
    pub valence: u8
    pub mass   : u8

    statik ELEMENTS = Vec::new

    statik load -> Error
        $content = open "content.dat"?
            .readall?
        $numberOfElements = content.parsePiece::<u8>?

        ty Spawner
            content: RawBytes

            next -> ElementInfo?
                if i.content.isEmpty then return None

                $valence = i.content.parsePiece?
                $mass    = i.content.parsePiece?

                Some ~ ElementInfo::new valence mass


        Self::ELEMENTS.reserve numberOfElements
        Self::ELEMENTS.spawn ~ Spawner::new content
